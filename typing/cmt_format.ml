(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

ouvre Cmi_format
ouvre Typedtree

(* Note that in Typerex, there is an awful hack to save a cmt file
   together with the interface file that was generated by ocaml (this
   is because the installed version of ocaml might differ from the one
   integrated in Typerex).
*)



soit read_magic_number ic =
  soit len_magic_number = String.length Config.cmt_magic_number dans
  soit magic_number = String.create len_magic_number dans
  really_input ic magic_number 0 len_magic_number;
  magic_number

type binary_annots =
  | Packed de Types.signature * string list
  | Implementation de structure
  | Interface de signature
  | Partial_implementation de binary_part array
  | Partial_interface de binary_part array

et binary_part =
| Partial_structure de structure
| Partial_structure_item de structure_item
| Partial_expression de expression
| Partial_pattern de pattern
| Partial_class_expr de class_expr
| Partial_signature de signature
| Partial_signature_item de signature_item
| Partial_module_type de module_type

type cmt_infos = {
  cmt_modname : string;
  cmt_annots : binary_annots;
  cmt_value_dependencies :
    (Types.value_description * Types.value_description) list;
  cmt_comments : (string * Location.t) list;
  cmt_args : string array;
  cmt_sourcefile : string option;
  cmt_builddir : string;
  cmt_loadpath : string list;
  cmt_source_digest : Digest.t option;
  cmt_initial_env : Env.t;
  cmt_imports : (string * Digest.t) list;
  cmt_interface_digest : Digest.t option;
  cmt_use_summaries : bool;
}

type error =
    Not_a_typedtree de string

soit need_to_clear_env =
  essaie ignore (Sys.getenv "OCAML_BINANNOT_WITHENV"); faux
  avec Not_found -> vrai

soit keep_only_summary = Env.keep_only_summary

module ClearEnv  = TypedtreeMap.MakeMap (struct
  ouvre TypedtreeMap
  inclus DefaultMapArgument

  soit leave_pattern p = { p avec pat_env = keep_only_summary p.pat_env }
  soit leave_expression e =
    soit exp_extra = List.map (fonction
        (Texp_open (ovf, path, lloc, env), loc, attrs) ->
          (Texp_open (ovf, path, lloc, keep_only_summary env), loc, attrs)
      | exp_extra -> exp_extra) e.exp_extra dans
    { e avec
      exp_env = keep_only_summary e.exp_env;
      exp_extra = exp_extra }
  soit leave_class_expr c =
    { c avec cl_env = keep_only_summary c.cl_env }
  soit leave_module_expr m =
    { m avec mod_env = keep_only_summary m.mod_env }
  soit leave_structure s =
    { s avec str_final_env = keep_only_summary s.str_final_env }
  soit leave_structure_item str =
    { str avec str_env = keep_only_summary str.str_env }
  soit leave_module_type m =
    { m avec mty_env = keep_only_summary m.mty_env }
  soit leave_signature s =
    { s avec sig_final_env = keep_only_summary s.sig_final_env }
  soit leave_signature_item s =
    { s avec sig_env = keep_only_summary s.sig_env }
  soit leave_core_type c =
    { c avec ctyp_env = keep_only_summary c.ctyp_env }
  soit leave_class_type c =
    { c avec cltyp_env = keep_only_summary c.cltyp_env }

fin)

soit clear_part p = filtre p avec
  | Partial_structure s -> Partial_structure (ClearEnv.map_structure s)
  | Partial_structure_item s ->
    Partial_structure_item (ClearEnv.map_structure_item s)
  | Partial_expression e -> Partial_expression (ClearEnv.map_expression e)
  | Partial_pattern p -> Partial_pattern (ClearEnv.map_pattern p)
  | Partial_class_expr ce -> Partial_class_expr (ClearEnv.map_class_expr ce)
  | Partial_signature s -> Partial_signature (ClearEnv.map_signature s)
  | Partial_signature_item s ->
    Partial_signature_item (ClearEnv.map_signature_item s)
  | Partial_module_type s -> Partial_module_type (ClearEnv.map_module_type s)

soit clear_env binary_annots =
  si need_to_clear_env alors
    filtre binary_annots avec
      | Implementation s -> Implementation (ClearEnv.map_structure s)
      | Interface s -> Interface (ClearEnv.map_signature s)
      | Packed _ -> binary_annots
      | Partial_implementation array ->
        Partial_implementation (Array.map clear_part array)
      | Partial_interface array ->
        Partial_interface (Array.map clear_part array)

  sinon binary_annots




exception Error de error

soit input_cmt ic = (input_value ic : cmt_infos)

soit output_cmt oc cmt =
  output_string oc Config.cmt_magic_number;
  output_value oc (cmt : cmt_infos)

soit read filename =
(*  Printf.fprintf stderr "Cmt_format.read %s\n%!" filename; *)
  soit ic = open_in_bin filename dans
  essaie
    soit magic_number = read_magic_number ic dans
    soit cmi, cmt =
      si magic_number = Config.cmt_magic_number alors
        None, Some (input_cmt ic)
      sinon si magic_number = Config.cmi_magic_number alors
        soit cmi = Cmi_format.input_cmi ic dans
        soit cmt = essaie
                    soit magic_number = read_magic_number ic dans
                    si magic_number = Config.cmt_magic_number alors
                      soit cmt = input_cmt ic dans
                      Some cmt
                    sinon None
          avec _ -> None
        dans
        Some cmi, cmt
      sinon
        raise(Cmi_format.Error(Cmi_format.Not_an_interface filename))
    dans
    close_in ic;
(*    Printf.fprintf stderr "Cmt_format.read done\n%!"; *)
    cmi, cmt
  avec e ->
    close_in ic;
    raise e

soit string_of_file filename =
  soit ic = open_in filename dans
  soit s = Misc.string_of_file ic dans
  close_in ic;
  s

soit read_cmt filename =
  filtre read filename avec
      _, None -> raise (Error (Not_a_typedtree filename))
    | _, Some cmt -> cmt

soit read_cmi filename =
  filtre read filename avec
      None, _ ->
        raise (Cmi_format.Error (Cmi_format.Not_an_interface filename))
    | Some cmi, _ -> cmi

soit saved_types = ref []
soit value_deps = ref []

soit clear () =
  saved_types := [];
  value_deps := []

soit add_saved_type b = saved_types := b :: !saved_types
soit get_saved_types () = !saved_types
soit set_saved_types l = saved_types := l

soit record_value_dependency vd1 vd2 =
  si vd1.Types.val_loc <> vd2.Types.val_loc alors
    value_deps := (vd1, vd2) :: !value_deps

soit save_cmt filename modname binary_annots sourcefile initial_env sg =
  si !Clflags.binary_annotations && not !Clflags.print_types alors dÃ©but
    soit imports = Env.imported_units () dans
    soit oc = open_out_bin filename dans
    soit this_crc =
      filtre sg avec
          None -> None
        | Some (sg) ->
          soit cmi = {
            cmi_name = modname;
            cmi_sign = sg;
            cmi_flags =
            si !Clflags.recursive_types alors [Cmi_format.Rectypes] sinon [];
            cmi_crcs = imports;
          } dans
          Some (output_cmi filename oc cmi)
    dans
    soit source_digest = Misc.may_map Digest.file sourcefile dans
    soit cmt = {
      cmt_modname = modname;
      cmt_annots = clear_env binary_annots;
      cmt_value_dependencies = !value_deps;
      cmt_comments = Lexer.comments ();
      cmt_args = Sys.argv;
      cmt_sourcefile = sourcefile;
      cmt_builddir =  Sys.getcwd ();
      cmt_loadpath = !Config.load_path;
      cmt_source_digest = source_digest;
      cmt_initial_env = si need_to_clear_env alors
          keep_only_summary initial_env sinon initial_env;
      cmt_imports = List.sort compare imports;
      cmt_interface_digest = this_crc;
      cmt_use_summaries = need_to_clear_env;
    } dans
    output_cmt oc cmt;
    close_out oc;
  fin;
  clear ()

